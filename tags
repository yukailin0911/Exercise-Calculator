!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_OUTPUT_MODE	u-ctags	/u-ctags or e-ctags/
!_TAG_PROGRAM_AUTHOR	Universal Ctags Team	//
!_TAG_PROGRAM_NAME	Universal Ctags	/Derived from Exuberant Ctags/
!_TAG_PROGRAM_URL	https://ctags.io/	/official site/
!_TAG_PROGRAM_VERSION	0.0.0	/c2a5caa/
ADD	element.h	/^    ADD,$/;"	e	enum:Kind
BUF_SIZE	main.cpp	/^#define BUF_SIZE /;"	d	file:
CALCULATOR_H	calculator.h	/^#define CALCULATOR_H$/;"	d
CAPACITY	testMyStack.cpp	/^#define CAPACITY /;"	d	file:
CFLAGS	Makefile	/^CFLAGS = -Wall$/;"	m
Calculator	calculator.h	/^	Calculator(): _stack(MyStack(STACK_CAPACITY)), _elementBuf(NULL), _bufSize(0) {}$/;"	f	class:Calculator
Calculator	calculator.h	/^class Calculator {$/;"	c
DIVIDE	element.h	/^    DIVIDE,$/;"	e	enum:Kind
Element	element.h	/^	Element() {}$/;"	f	class:Element
Element	element.h	/^	Element(const Kind &k): _kind(k) {}$/;"	f	class:Element
Element	element.h	/^class Element {$/;"	c
ElementNode	element.h	/^	ElementNode(Element * const e): _next(NULL), _data(e) {}$/;"	f	class:ElementNode
ElementNode	element.h	/^class ElementNode {$/;"	c
HIGH	element.h	/^    HIGH,$/;"	e	enum:OperatorPriority
HIGHEST	element.h	/^    HIGHEST$/;"	e	enum:OperatorPriority
Kind	element.h	/^enum Kind {$/;"	g
LOW	element.h	/^    LOW,$/;"	e	enum:OperatorPriority
L_PARENTHESIS	element.h	/^    L_PARENTHESIS,$/;"	e	enum:Kind
MEDIUM	element.h	/^    MEDIUM,$/;"	e	enum:OperatorPriority
MULTIPLY	element.h	/^    MULTIPLY,$/;"	e	enum:Kind
MY_ELEMENT_H	element.h	/^#define MY_ELEMENT_H$/;"	d
MY_QUEUE_H	myQueue.h	/^#define MY_QUEUE_H$/;"	d
MY_STACK_H	myStack.h	/^#define MY_STACK_H$/;"	d
MyQueue	myQueue.h	/^	MyQueue(): _front(NULL), _rear(NULL) {}$/;"	f	class:MyQueue
MyQueue	myQueue.h	/^class MyQueue {$/;"	c
MyStack	myStack.cpp	/^MyStack::MyStack(const int &size): _top(-1), _capacity(size) {$/;"	f	class:MyStack
MyStack	myStack.h	/^class MyStack {$/;"	c
OBJS_CALCULATOR	Makefile	/^OBJS_CALCULATOR = main.o calculator.o myStack.o myQueue.o element.o$/;"	m
OBJS_TEST_ELEMENT	Makefile	/^OBJS_TEST_ELEMENT = testElement.o element.o$/;"	m
OBJS_TEST_MY_QUEUE	Makefile	/^OBJS_TEST_MY_QUEUE = testMyQueue.o myQueue.o element.o$/;"	m
OBJS_TEST_MY_STACK	Makefile	/^OBJS_TEST_MY_STACK = testMyStack.o myStack.o element.o$/;"	m
OPERAND	element.h	/^    OPERAND,$/;"	e	enum:Kind
Operand	element.h	/^	Operand(const double &d): Element(OPERAND), _value(d) {}$/;"	f	class:Operand
Operand	element.h	/^class Operand: public Element {$/;"	c
Operator	element.cpp	/^Operator::Operator(const char &c) {$/;"	f	class:Operator
Operator	element.h	/^class Operator: public Element {$/;"	c
OperatorPriority	element.h	/^enum OperatorPriority {$/;"	g
R_PARENTHESIS	element.h	/^    R_PARENTHESIS$/;"	e	enum:Kind
STACK_CAPACITY	calculator.h	/^    #define STACK_CAPACITY /;"	d
SUBSTRACT	element.h	/^    SUBSTRACT,$/;"	e	enum:Kind
_array	myStack.h	/^	Element **_array;$/;"	m	class:MyStack	typeref:typename:Element **
_bufSize	calculator.h	/^	size_t _bufSize;$/;"	m	class:Calculator	typeref:typename:size_t
_capacity	myStack.h	/^	int _capacity;$/;"	m	class:MyStack	typeref:typename:int
_data	element.h	/^	Element * const _data;$/;"	m	class:ElementNode	typeref:typename:Element * const
_elementBuf	calculator.h	/^	Element** _elementBuf;$/;"	m	class:Calculator	typeref:typename:Element **
_front	myQueue.h	/^	ElementNode *_front;$/;"	m	class:MyQueue	typeref:typename:ElementNode *
_kind	element.h	/^	Kind _kind;$/;"	m	class:Element	typeref:typename:Kind
_next	element.h	/^	ElementNode *_next;$/;"	m	class:ElementNode	typeref:typename:ElementNode *
_priority	element.h	/^	OperatorPriority _priority;$/;"	m	class:Operator	typeref:typename:OperatorPriority
_queue	calculator.h	/^	MyQueue _queue;$/;"	m	class:Calculator	typeref:typename:MyQueue
_rear	myQueue.h	/^	ElementNode *_rear;$/;"	m	class:MyQueue	typeref:typename:ElementNode *
_stack	calculator.h	/^	MyStack _stack;$/;"	m	class:Calculator	typeref:typename:MyStack
_top	myStack.h	/^	int _top;$/;"	m	class:MyStack	typeref:typename:int
_value	element.h	/^	double _value;$/;"	m	class:Operand	typeref:typename:double
binaryEval	calculator.cpp	/^Element* Calculator::binaryEval(const Operator * const op,$/;"	f	class:Calculator	typeref:typename:Element *
calculate	calculator.cpp	/^void Calculator::calculate(const char * const expression) {$/;"	f	class:Calculator	typeref:typename:void
calculator	Makefile	/^calculator: ${OBJS_CALCULATOR}$/;"	t
clean	Makefile	/^clean:$/;"	t
clearBuf	calculator.cpp	/^void Calculator::clearBuf() {$/;"	f	class:Calculator	typeref:typename:void
clearQueue	calculator.cpp	/^void Calculator::clearQueue() {$/;"	f	class:Calculator	typeref:typename:void
clearStack	calculator.cpp	/^void Calculator::clearStack() {$/;"	f	class:Calculator	typeref:typename:void
data	element.cpp	/^Element* ElementNode::data() const {$/;"	f	class:ElementNode	typeref:typename:Element *
deQueue	myQueue.cpp	/^Element* MyQueue::deQueue() {$/;"	f	class:MyQueue	typeref:typename:Element *
deleteFront	myQueue.cpp	/^void MyQueue::deleteFront() {$/;"	f	class:MyQueue	typeref:typename:void
enQueue	myQueue.cpp	/^void MyQueue::enQueue(Element * const element) {$/;"	f	class:MyQueue	typeref:typename:void
evaluate	calculator.cpp	/^void Calculator::evaluate(MyQueue &queue) {$/;"	f	class:Calculator	typeref:typename:void
isEmpty	myQueue.cpp	/^bool MyQueue::isEmpty() const {$/;"	f	class:MyQueue	typeref:typename:bool
isEmpty	myStack.cpp	/^bool MyStack::isEmpty() const {$/;"	f	class:MyStack	typeref:typename:bool
isFull	myStack.cpp	/^bool MyStack::isFull() const {$/;"	f	class:MyStack	typeref:typename:bool
isLParenthesis	element.cpp	/^bool Element::isLParenthesis() const {$/;"	f	class:Element	typeref:typename:bool
isOperator	element.cpp	/^bool Element::isOperator() const {$/;"	f	class:Element	typeref:typename:bool
isRParenthesis	element.cpp	/^bool Element::isRParenthesis() const {$/;"	f	class:Element	typeref:typename:bool
kind	element.cpp	/^Kind Operator::kind() const {$/;"	f	class:Operator	typeref:typename:Kind
main	main.cpp	/^int main() {$/;"	f	typeref:typename:int
main	testElement.cpp	/^int main() {$/;"	f	typeref:typename:int
main	testMyQueue.cpp	/^int main() {$/;"	f	typeref:typename:int
main	testMyStack.cpp	/^int main() {$/;"	f	typeref:typename:int
next	element.cpp	/^ElementNode* ElementNode::next() const {$/;"	f	class:ElementNode	typeref:typename:ElementNode *
operator >=	element.cpp	/^bool Operator::operator>=(const Operator &op) const {$/;"	f	class:Operator	typeref:typename:bool
parse	calculator.cpp	/^Element** Calculator::parse(const char * const expression) {$/;"	f	class:Calculator	typeref:typename:Element **
pop	myStack.cpp	/^Element* MyStack::pop() {$/;"	f	class:MyStack	typeref:typename:Element *
postfixConvert	calculator.cpp	/^void Calculator::postfixConvert(Element * const * const elementBuf) {$/;"	f	class:Calculator	typeref:typename:void
printPopped	testMyStack.cpp	/^void printPopped(const Element * const e) {$/;"	f	typeref:typename:void
printPushed	testMyStack.cpp	/^void printPushed(const Element * const e) {$/;"	f	typeref:typename:void
printTop	testMyStack.cpp	/^void printTop(const Element * const e) {$/;"	f	typeref:typename:void
push	myStack.cpp	/^void MyStack::push(Element *element) {$/;"	f	class:MyStack	typeref:typename:void
resize	myStack.cpp	/^void MyStack::resize() {$/;"	f	class:MyStack	typeref:typename:void
setNext	element.cpp	/^void ElementNode::setNext(ElementNode *node) {$/;"	f	class:ElementNode	typeref:typename:void
setPriority	element.cpp	/^void Operator::setPriority(const OperatorPriority &p) {$/;"	f	class:Operator	typeref:typename:void
testDeQueue	testMyQueue.cpp	/^void testDeQueue() {$/;"	f	typeref:typename:void
testElement	Makefile	/^testElement: ${OBJS_TEST_ELEMENT}$/;"	t
testEnQueue	testMyQueue.cpp	/^void testEnQueue() {$/;"	f	typeref:typename:void
testIsEmpty	testMyQueue.cpp	/^void testIsEmpty() {$/;"	f	typeref:typename:void
testIsEmpty	testMyStack.cpp	/^void testIsEmpty() {$/;"	f	typeref:typename:void
testIsFull	testMyStack.cpp	/^void testIsFull() {$/;"	f	typeref:typename:void
testIsLParenthesis	testElement.cpp	/^void testIsLParenthesis() {$/;"	f	typeref:typename:void
testIsOperator	testElement.cpp	/^void testIsOperator() {$/;"	f	typeref:typename:void
testIsRParenthesis	testElement.cpp	/^void testIsRParenthesis() {$/;"	f	typeref:typename:void
testMyQueue	Makefile	/^testMyQueue: ${OBJS_TEST_MY_QUEUE}$/;"	t
testMyStack	Makefile	/^testMyStack: ${OBJS_TEST_MY_STACK}$/;"	t
testOperatorOverloading	testElement.cpp	/^void testOperatorOverloading() {$/;"	f	typeref:typename:void
testPop	testMyStack.cpp	/^void testPop() {$/;"	f	typeref:typename:void
testPush	testMyStack.cpp	/^void testPush() {$/;"	f	typeref:typename:void
testTop	testMyStack.cpp	/^void testTop() {$/;"	f	typeref:typename:void
top	myStack.cpp	/^Element* MyStack::top() const {$/;"	f	class:MyStack	typeref:typename:Element *
value	element.cpp	/^double Operand::value() const {$/;"	f	class:Operand	typeref:typename:double
~Calculator	calculator.cpp	/^Calculator::~Calculator() {$/;"	f	class:Calculator
~MyQueue	myQueue.cpp	/^MyQueue::~MyQueue() {$/;"	f	class:MyQueue
~MyStack	myStack.cpp	/^MyStack::~MyStack() {$/;"	f	class:MyStack
